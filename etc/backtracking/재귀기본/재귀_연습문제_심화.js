// =================================================================
// 문제 4: 이진 탐색 (Binary Search)
// =================================================================
/*
문제 설명:
**정렬된 정수 배열** `sortedArr`에서 `target` 값을 찾는 재귀적인 이진 탐색 함수를 작성하세요.
이진 탐색은 배열의 중간 요소를 확인하여 찾으려는 값이 그보다 큰지 작은지에 따라 탐색 범위를 절반씩 줄여나가는 효율적인 탐색 알고리즘입니다.

힌트:
- 재귀 함수는 탐색 범위(시작 인덱스 `start`, 끝 인덱스 `end`)를 인자로 받아야 합니다.
- 중간 인덱스 `mid`를 계산하고 `sortedArr[mid]`와 `target`을 비교합니다.
- `target`이 더 작으면 왼쪽 절반(`start` ~ `mid-1`)을, 더 크면 오른쪽 절반(`mid+1` ~ `end`)을 재귀적으로 탐색합니다.
- `start`가 `end`보다 커지면 값을 찾지 못한 것입니다. (기본 조건)

입출력 예시:
- 입력: arr = [1, 3, 5, 7, 9, 11, 13], target = 9
- 출력: 4 (인덱스)

- 입력: arr = [1, 3, 5, 7, 9, 11, 13], target = 6
- 출력: -1 (찾지 못함)
*/
function solution4(sortedArr, target) {
  // 재귀적으로 탐색을 수행할 내부 함수를 정의합니다.
  function binarySearchRecursive(start, end) {
    // 여기에 코드를 작성하세요.
    let mid = Math.floor((start+end)/2);
    console.log(start,end,mid);
    console.log(sortedArr[mid]);

    if(sortedArr[mid]===target){
      return mid;
    }
    if (mid===0){
      return -1;
    }
    if(sortedArr[mid]<target){
      return binarySearchRecursive(mid+1,end);
    }else{
      return binarySearchRecursive(start,mid-1);
    }
  }

  return binarySearchRecursive(0, sortedArr.length - 1);
}

// console.log("이진 탐색 ([1, 3, 5, 7, 9, 11, 13], 9):", solution4([1, 3, 5, 7, 9, 11, 13], 9));
console.log("이진 탐색 ([1, 3, 5, 7, 9, 11, 13], 6):", solution4([1, 3, 5, 7, 9, 11, 13], 6));


// =================================================================
// 문제 5: 배열의 모든 조합 생성 (Power Set)
// =================================================================
/*
문제 설명:
주어진 배열 `arr`의 모든 가능한 부분집합(멱집합, Power Set)을 구하는 함수를 작성하세요.
예를 들어, `[1, 2]`의 부분집합은 `[]`, `[1]`, `[2]`, `[1, 2]` 입니다.

힌트:
- 재귀 함수는 현재까지 만들어진 부분집합 `currentSet`과 탐색할 원소의 인덱스 `index`를 인자로 받습니다.
- 각 원소에 대해 '포함하는 경우'와 '포함하지 않는 경우' 두 가지로 나누어 재귀 호출을 진행합니다.

입출력 예시:
- 입력: [1, 2, 3]
- 출력: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] (순서는 상관 없음)
*/
function solution5(arr) {
  const result = [];

  function findSubsets(index, currentSubset) {
    // 여기에 코드를 작성하세요.

  }

  findSubsets(0, []);
  return result;
}

// console.log("모든 조합 생성 ([1, 2, 3]):", solution5([1, 2, 3]));


// =================================================================
// 문제 6: 하노이의 탑
// =================================================================
/*
문제 설명:
세 개의 기둥('A', 'B', 'C')과 N개의 원반이 있습니다. 원반은 크기가 모두 다르며, 처음에는 모든 원반이 'A' 기둥에 큰 것이 아래에 오도록 쌓여있습니다.
다음 규칙에 따라 모든 원반을 'A'에서 'C'로 옮기는 과정을 출력하는 함수를 작성하세요.
1. 한 번에 하나의 원반만 옮길 수 있습니다.
2. 큰 원반은 작은 원반 위에 놓을 수 없습니다.

힌트:
- N개의 원반을 A에서 C로 옮기려면:
  1. N-1개의 원반을 A에서 B로 옮긴다 (C를 보조 기둥으로 사용).
  2. 가장 큰 원반(N번째)을 A에서 C로 옮긴다.
  3. N-1개의 원반을 B에서 C로 옮긴다 (A를 보조 기둥으로 사용).

입출력 예시:
- 입력: 3
- 출력:
  1번 원반: A -> C
  2번 원반: A -> B
  1번 원반: C -> B
  3번 원반: A -> C
  1번 원반: B -> A
  2번 원반: B -> C
  1번 원반: A -> C
*/
function solution6(n) {
  const moves = [];

  function hanoi(num, from, to, aux) {
    // 여기에 코드를 작성하세요.

  }

  hanoi(n, 'A', 'C', 'B');
  return moves.join('\n');
}

// console.log("하노이의 탑 (3):\n" + solution6(3));
