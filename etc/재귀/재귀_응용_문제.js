
// =================================================================
// 문제 1: N-Queens
// =================================================================
/*
문제 설명:
N x N 크기의 체스판에 N개의 퀸을 서로 공격할 수 없도록 배치하는 모든 경우의 수를 찾는 함수를 작성하세요.
퀸은 가로, 세로, 대각선 방향으로 원하는 만큼 이동할 수 있습니다.

힌트:
- 백트래킹을 사용합니다. 재귀 함수는 현재 몇 번째 행(row)에 퀸을 놓을 차례인지를 인자로 받습니다.
- 각 행에는 반드시 하나의 퀸만 놓일 수 있습니다.
- 재귀 함수 내에서 현재 행의 모든 열(column)을 순회하며 퀸을 놓아봅니다.
- 퀸을 놓기 전에, 그 위치가 이전에 놓인 다른 퀸들에게 공격받는지(세로, 대각선) 확인하는 함수가 필요합니다.
- 유효한 위치에 퀸을 놓고, 다음 행으로 재귀 호출을 진행합니다.
- 재귀 호출이 끝나면, 놓았던 퀸을 다시 제거하고(백트래킹) 다음 열을 시도합니다.

입출력 예시:
- 입력: 4
- 출력: 2 (4x4 체스판에서 4개의 퀸을 놓는 경우의 수)
  (배치 예시: [[".Q..","...Q","Q...","..Q."], ["..Q.","Q...","...Q",".Q.."]])
  * 실제 출력은 경우의 수(정수)만 반환해도 됩니다.
*/
function solution1(n) {
  let count = 0;

  function isSafe(board, row, col) {
    // 여기에 유효성 검사 로직을 작성하세요.
    // 1. 세로 방향 검사
    // 2. 왼쪽 위 대각선 검사
    // 3. 오른쪽 위 대각선 검사
  }

  function solve(board, row) {
    // 여기에 재귀 로직을 작성하세요.
  }

  // 초기 체스판 생성 (예: 0으로 채워진 2D 배열)
  const board = Array.from({ length: n }, () => Array(n).fill(0));
  solve(board, 0);
  return count;
}

// console.log("N-Queens (4):", solution1(4));


// =================================================================
// 문제 2: 전화번호 문자 조합
// =================================================================
/*
문제 설명:
2부터 9까지의 숫자가 포함된 문자열이 주어졌을 때, 그 숫자들이 나타낼 수 있는 모든 문자 조합을 반환하는 함수를 작성하세요.
전화기 다이얼에 각 숫자가 문자와 매핑되어 있는 것을 참고합니다. (1은 문자와 매핑되지 않음)
(2: "abc", 3: "def", 4: "ghi", 5: "jkl", 6: "mno", 7: "pqrs", 8: "tuv", 9: "wxyz")

힌트:
- 백트래킹을 사용합니다. 재귀 함수는 현재까지 만들어진 조합(currentCombination)과 탐색할 숫자의 인덱스(index)를 인자로 받습니다.
- 인덱스가 입력된 숫자 문자열의 길이에 도달하면, 현재 조합을 결과에 추가하고 재귀를 종료합니다.
- 현재 인덱스에 해당하는 숫자의 모든 문자(예: '2' -> 'a', 'b', 'c')에 대해 반복문을 실행합니다.
- 각 문자를 현재 조합에 추가하고, 다음 인덱스로 재귀 호출을 진행합니다.
- 재귀 호출이 끝나면, 추가했던 문자를 다시 제거(백트래킹)하고 다음 문자를 시도합니다.

입출력 예시:
- 입력: "23"
- 출력: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
*/
function solution2(digits) {
  if (!digits) return [];
  const map = {
    '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
    '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
  };
  const result = [];

  function backtrack(index, currentCombination) {
    // 여기에 재귀 로직을 작성하세요.
  }

  backtrack(0, "");
  return result;
}

// console.log('전화번호 문자 조합 ("23"):', solution2("23"));


// =================================================================
// 문제 3: 수식 생성하기
// =================================================================
/*
문제 설명:
숫자들로 이루어진 문자열과 목표값(target)이 주어집니다. 숫자들 사이에 +, -, * 연산자를 삽입하여
목표값을 만들 수 있는 모든 유효한 수식을 찾는 함수를 작성하세요.

힌트:
- 이 문제는 일반적인 백트래킹보다 조금 더 복잡합니다. 곱셈(*)은 덧셈/뺄셈보다 우선순위가 높기 때문입니다.
- 재귀 함수는 현재까지 계산된 값(currentValue), 이전 연산의 피연산자(previousOperand),
  현재까지 만들어진 수식(currentExpression), 그리고 다음 숫자를 가리키는 인덱스(index)를 인자로 받습니다.
- 재귀 호출 시, 다음 숫자를 하나 또는 그 이상 묶어서 하나의 피연산자로 만듭니다. (예: "123"에서 "1", "12", "123")
- 덧셈/뺄셈: currentValue에 새로운 피연산자를 더하거나 뺍니다.
- 곱셈: currentValue에서 previousOperand를 먼저 빼고, (previousOperand * newOperand)를 더합니다.
  (예: 2 + 3 * 4를 계산할 때, (2+3)에서 3을 빼고 3*4를 더하면 2 + 12가 됩니다.)

입출력 예시:
- 입력: num = "123", target = 6
- 출력: ["1+2+3", "1*2*3"]

- 입력: num = "232", target = 8
- 출력: ["2*3+2", "2+3*2"]
*/
function solution3(num, target) {
  const result = [];

  function backtrack(index, currentPath, currentValue, prevOperand) {
    // 여기에 재귀 로직을 작성하세요.
  }

  backtrack(0, "", 0, 0);
  return result;
}

// console.log('수식 생성하기 ("123", 6):', solution3("123", 6));


// =================================================================
// 문제 4: 유니크한 이진 탐색 트리 II
// =================================================================
/*
문제 설명:
정수 n이 주어졌을 때, 1부터 n까지의 값을 가지는 모든 구조적으로 유니크한
이진 탐색 트리(BST)를 생성하는 함수를 작성하세요.

힌트:
- 재귀 함수는 특정 범위의 숫자(start, end)로 만들 수 있는 모든 유니크한 BST의 루트 노드 리스트를 반환합니다.
- 1부터 n까지의 각 숫자 i를 순서대로 루트 노드로 선택합니다.
- 숫자 i가 루트일 때, 왼쪽 서브트리는 1부터 i-1까지의 숫자로 만들어지고,
  오른쪽 서브트리는 i+1부터 n까지의 숫자로 만들어집니다.
- 왼쪽 서브트리가 될 수 있는 모든 트리와 오른쪽 서브트리가 될 수 있는 모든 트리를 재귀적으로 구합니다.
- 이들의 모든 조합을 만들어 현재 루트 i에 연결하고, 결과 리스트에 추가합니다.
- 기본 조건(base case)은 start > end일 때이며, 이 경우 [null]을 반환하여 리프 노드임을 표시합니다.

입출력 예시:
- 입력: 3
- 출력: 5개의 유니크한 BST의 루트 노드 리스트
  (트리 구조를 직접 출력하기는 어려우므로, 개념을 이해하고 구현하는 데 집중하세요.
   반환값은 트리 노드 객체들의 배열이 됩니다.)
*/

// 트리를 구성할 노드 클래스 (주어진 것으로 가정)
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function solution4(n) {
  if (n === 0) return [];

  function generateTrees(start, end) {
    // 여기에 재귀 로직을 작성하세요.
  }

  return generateTrees(1, n);
}

// console.log("유니크한 이진 탐색 트리 (3):", solution4(3));


// =================================================================
// 문제 5: 스도쿠 풀기
// =================================================================
/*
문제 설명:
부분적으로 채워진 9x9 스도쿠 보드를 해결하는 함수를 작성하세요.
빈칸은 '.' 문자로 표시되어 있습니다.

힌트:
- 백트래킹을 사용합니다. 빈칸을 하나씩 채워나가는 재귀 함수를 작성합니다.
- 9x9 보드를 순회하여 첫 번째 빈칸(.)을 찾습니다.
- 빈칸을 찾으면 1부터 9까지의 숫자를 하나씩 시도해봅니다.
- 숫자를 놓기 전에, 그 숫자가 현재 위치의 가로, 세로, 3x3 박스 규칙에 유효한지 확인하는 함수가 필요합니다.
- 유효하다면 숫자를 놓고, 다음 빈칸을 채우기 위해 재귀 호출을 합니다.
- 재귀 호출의 결과가 true(스도쿠 해결 성공)이면, 그대로 true를 반환하여 연쇄적으로 재귀를 종료시킵니다.
- 재귀 호출의 결과가 false(해결 실패)이면, 놓았던 숫자를 다시 '.'으로 바꾸고(백트래킹) 다음 숫자를 시도합니다.
- 모든 숫자를 시도했는데도 해결하지 못하면 false를 반환합니다.
- 보드를 모두 순회했는데 빈칸이 없으면, 스도쿠가 해결된 것이므로 true를 반환합니다.

입출력 예시:
- 입력: (9x9 2D 배열)
  [
    ["5","3",".",".","7",".",".",".","."],
    ["6",".",".","1","9","5",".",".","."],
    [".","9","8",".",".",".",".","6","."],
    ["8",".",".",".","6",".",".",".","3"],
    ["4",".",".","8",".","3",".",".","1"],
    ["7",".",".",".","2",".",".",".","6"],
    [".","6",".",".",".",".","2","8","."],
    [".",".",".","4","1","9",".",".","5"],
    [".",".",".",".","8",".",".","7","9"]
  ]
- 출력: (해결된 9x9 2D 배열)
*/
function solution5(board) {
  function isValid(row, col, num) {
    // 여기에 유효성 검사 로직을 작성하세요.
  }

  function solve() {
    // 여기에 재귀/백트래킹 로직을 작성하세요.
  }

  solve();
  return board; // board는 solve 함수 내에서 직접 수정됩니다.
}

// const sudokuBoard = [
//   ["5","3",".",".","7",".",".",".","."],
//   ["6",".",".","1","9","5",".",".","."],
//   [".","9","8",".",".",".",".","6","."],
//   ["8",".",".",".","6",".",".",".","3"],
//   ["4",".",".","8",".","3",".",".","1"],
//   ["7",".",".",".","2",".",".",".","6"],
//   [".","6",".",".",".",".","2","8","."],
//   [".",".",".","4","1","9",".",".","5"],
//   [".",".",".",".","8",".",".","7","9"]
// ];
// console.log("스도쿠 풀기:", solution5(sudokuBoard));
